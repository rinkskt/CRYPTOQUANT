"""
Portfolio Optimization Module

Otimiza√ß√£o e recomenda√ß√µes de aloca√ß√£o do portf√≥lio.
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
from typing import Dict, List, Optional, Tuple
from datetime import datetime, timedelta
from scipy.optimize import minimize

from app.analytics.portfolio.rebalance import PortfolioRebalancer
from .portfolio_form import load_portfolio, PortfolioPosition
from ...api_client import get_ohlcv_data
from app.analytics.portfolio import get_portfolio_data

def calculate_portfolio_metrics(weights: np.ndarray, 
                             returns: pd.DataFrame,
                             risk_free_rate: float = 0.03) -> Tuple[float, float, float]:
    """
    Calcula retorno, volatilidade e Sharpe ratio do portf√≥lio.
    """
    portfolio_return = np.sum(returns.mean() * weights) * 252
    portfolio_std = np.sqrt(np.dot(weights.T, np.dot(returns.cov() * 252, weights)))
    sharpe_ratio = (portfolio_return - risk_free_rate) / portfolio_std
    
    return portfolio_return, portfolio_std, sharpe_ratio

def optimize_portfolio(returns: pd.DataFrame,
                     risk_free_rate: float = 0.03,
                     target_return: Optional[float] = None) -> Dict[str, float]:
    """
    Otimiza o portf√≥lio usando o modelo de Markowitz.
    """
    n_assets = len(returns.columns)
    
    def objective(weights):
        return -calculate_portfolio_metrics(weights, returns, risk_free_rate)[2]
    
    constraints = [
        {'type': 'eq', 'fun': lambda x: np.sum(x) - 1}  # soma dos pesos = 1
    ]
    
    if target_return is not None:
        constraints.append({
            'type': 'eq',
            'fun': lambda x: np.sum(returns.mean() * x) * 252 - target_return
        })
    
    bounds = tuple((0, 1) for _ in range(n_assets))
    initial_weights = np.array([1/n_assets] * n_assets)
    
    result = minimize(objective, initial_weights,
                     method='SLSQP',
                     bounds=bounds,
                     constraints=constraints)
    
    if result.success:
        return dict(zip(returns.columns, result.x))
    else:
        return dict(zip(returns.columns, initial_weights))

def generate_efficient_frontier(returns: pd.DataFrame,
                              n_portfolios: int = 100) -> pd.DataFrame:
    """
    Gera a fronteira eficiente de Markowitz.
    """
    # Range de retornos alvos
    min_ret = returns.mean().min() * 252
    max_ret = returns.mean().max() * 252
    target_returns = np.linspace(min_ret, max_ret, n_portfolios)
    
    results = []
    for target_ret in target_returns:
        weights = optimize_portfolio(returns, target_return=target_ret)
        ret, vol, sharpe = calculate_portfolio_metrics(
            np.array(list(weights.values())),
            returns
        )
        results.append({
            'return': ret,
            'volatility': vol,
            'sharpe': sharpe,
            'weights': weights
        })
    
    return pd.DataFrame(results)

def create_efficient_frontier_chart(ef_data: pd.DataFrame,
                                 current_portfolio: Optional[Tuple[float, float]] = None) -> go.Figure:
    """
    Cria gr√°fico da fronteira eficiente.
    """
    fig = go.Figure()
    
    # Fronteira eficiente
    fig.add_trace(go.Scatter(
        x=ef_data['volatility'],
        y=ef_data['return'],
        mode='lines',
        name='Fronteira Eficiente',
        line=dict(color='blue', width=2)
    ))
    
    # Portf√≥lio atual
    if current_portfolio:
        fig.add_trace(go.Scatter(
            x=[current_portfolio[1]],
            y=[current_portfolio[0]],
            mode='markers',
            name='Portf√≥lio Atual',
            marker=dict(color='red', size=10)
        ))
    
    # Portf√≥lio de m√°ximo Sharpe
    max_sharpe_idx = ef_data['sharpe'].idxmax()
    fig.add_trace(go.Scatter(
        x=[ef_data.loc[max_sharpe_idx, 'volatility']],
        y=[ef_data.loc[max_sharpe_idx, 'return']],
        mode='markers',
        name='M√°ximo Sharpe',
        marker=dict(color='green', size=10)
    ))
    
    fig.update_layout(
        title="Fronteira Eficiente",
        xaxis_title="Volatilidade Anualizada",
        yaxis_title="Retorno Esperado Anualizado",
        height=600,
        showlegend=True
    )
    
    return fig

def show_optimization_tab():
    """
    Mostra a aba de otimiza√ß√£o do portf√≥lio.
    """
    st.header("üéØ Otimiza√ß√£o de Portf√≥lio")
    
    # Carrega dados do portf√≥lio
    portfolio = load_portfolio()
    if not portfolio:
        st.warning("Nenhuma posi√ß√£o encontrada. Adicione ativos ao seu portf√≥lio primeiro.")
        return
    
    # Configura√ß√µes
    col1, col2 = st.columns(2)
    
    with col1:
        lookback_days = st.selectbox(
            "Per√≠odo de An√°lise",
            options=[30, 90, 180, 365],
            index=1,
            format_func=lambda x: f"√öltimos {x} dias",
            key="opt_lookback_days"
        )
    
    with col2:
        risk_free_rate = st.number_input(
            "Taxa Livre de Risco (a.a.)",
            min_value=0.0,
            max_value=0.2,
            value=0.03,
            format="%.2f",
            key="opt_risk_free_rate"
        )
    
    # Prepara dados
    end_date = datetime.now()
    start_date = end_date - timedelta(days=lookback_days)
    
    symbols = [pos.symbol for pos in portfolio]
    current_weights = {pos.symbol: pos.qty * pos.price_entry for pos in portfolio}
    total_value = sum(current_weights.values())
    current_weights = {k: v/total_value for k, v in current_weights.items()}
    
    # Carrega dados hist√≥ricos usando o novo m√≥dulo
    try:
        interval = "1d"
        limit = lookback_days

        portfolio_raw = get_portfolio_data(symbols, interval=interval, limit=limit)

        # Converte para DataFrame com timestamps como √≠ndice
        portfolio_data = pd.DataFrame()
        for symbol in symbols:
            if symbol in portfolio_raw:
                df = portfolio_raw[symbol].copy()
                df['timestamp'] = pd.to_datetime(df['timestamp'])
                df = df.set_index('timestamp')
                portfolio_data[symbol] = df['close']

        if portfolio_data.empty:
            st.error("N√£o foi poss√≠vel carregar dados hist√≥ricos.")
            return

    except Exception as e:
        st.error(f"Erro ao carregar dados hist√≥ricos: {str(e)}")
        return
    
    # Calcula retornos
    returns = portfolio_data.pct_change().dropna()
    
    # Calcula m√©tricas do portf√≥lio atual
    current_weights_array = np.array(list(current_weights.values()))
    current_return, current_vol, current_sharpe = calculate_portfolio_metrics(
        current_weights_array, returns, risk_free_rate
    )
    
    # Gera fronteira eficiente
    with st.spinner("Calculando fronteira eficiente..."):
        ef_data = generate_efficient_frontier(returns)
    
    # Mostra gr√°fico da fronteira eficiente
    config = {
        'displayModeBar': True,
        'displaylogo': False,
        'responsive': True
    }
    st.plotly_chart(
        create_efficient_frontier_chart(ef_data, (current_return, current_vol)),
        config=config,
        use_container_width=True
    )
    
    # Mostra diferentes estrat√©gias de otimiza√ß√£o
    st.subheader("Estrat√©gias de Aloca√ß√£o")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.write("**Portf√≥lio Atual**")
        current_metrics = pd.DataFrame({
            'M√©trica': ['Retorno Esperado', 'Volatilidade', 'Sharpe Ratio'],
            'Valor': [
                f"{current_return*100:.2f}%",
                f"{current_vol*100:.2f}%",
                f"{current_sharpe:.2f}"
            ]
        })
        st.dataframe(current_metrics.set_index('M√©trica'), width='stretch')
    
    with col2:
        st.write("**M√°ximo Sharpe Ratio**")
        max_sharpe_idx = ef_data['sharpe'].idxmax()
        max_sharpe_metrics = pd.DataFrame({
            'M√©trica': ['Retorno Esperado', 'Volatilidade', 'Sharpe Ratio'],
            'Valor': [
                f"{ef_data.loc[max_sharpe_idx, 'return']*100:.2f}%",
                f"{ef_data.loc[max_sharpe_idx, 'volatility']*100:.2f}%",
                f"{ef_data.loc[max_sharpe_idx, 'sharpe']:.2f}"
            ]
        })
        st.dataframe(max_sharpe_metrics.set_index('M√©trica'), width='stretch')
    
    with col3:
        st.write("**Risk Parity**")
        # Calcula pesos usando inverse volatility
        vols = returns.std()
        inv_vols = 1/vols
        risk_parity_weights = inv_vols/inv_vols.sum()
        rp_return, rp_vol, rp_sharpe = calculate_portfolio_metrics(
            risk_parity_weights.values, returns, risk_free_rate
        )
        
        risk_parity_metrics = pd.DataFrame({
            'M√©trica': ['Retorno Esperado', 'Volatilidade', 'Sharpe Ratio'],
            'Valor': [
                f"{rp_return*100:.2f}%",
                f"{rp_vol*100:.2f}%",
                f"{rp_sharpe:.2f}"
            ]
        })
        st.dataframe(risk_parity_metrics.set_index('M√©trica'), width='stretch')
    
    # Mostra composi√ß√µes sugeridas
    st.subheader("Composi√ß√µes Sugeridas")
    
    compositions = pd.DataFrame({
        'Atual': pd.Series(current_weights),
        'M√°ximo Sharpe': pd.Series(ef_data.loc[max_sharpe_idx, 'weights']),
        'Risk Parity': risk_parity_weights
    })
    
    # Formata percentuais
    st.dataframe(
        compositions.style.format("{:.2%}"),
        width='stretch'
    )
    
    # Sugest√µes de rebalanceamento
    st.subheader("Sugest√µes de Rebalanceamento")
    
    strategy = st.radio(
        "Escolha a estrat√©gia alvo:",
        ["M√°ximo Sharpe", "Risk Parity"],
        key="opt_strategy_choice"
    )
    
    target_weights = (ef_data.loc[max_sharpe_idx, 'weights'] 
                     if strategy == "M√°ximo Sharpe" 
                     else risk_parity_weights)
    
    # Calculate deviations using PortfolioRebalancer
    rebalancer = PortfolioRebalancer(
        positions={symbol: {'qty': pos.qty} for symbol, pos in zip(symbols, portfolio)},
        target_weights=target_weights,
        prices={symbol: pos.price_entry for symbol, pos in zip(symbols, portfolio)},
        total_value=total_value
    )
    deviations = rebalancer.calculate_deviations(relative=False)
    
    rebal_df = pd.DataFrame({
        'Peso Atual': pd.Series(current_weights),
        'Peso Alvo': target_weights,
        'Diferen√ßa': pd.Series(deviations)
    })
    
    # Adiciona sugest√£o de a√ß√£o
    rebal_df['A√ß√£o'] = rebal_df['Diferen√ßa'].apply(
        lambda x: 'COMPRAR' if x > 0.02 else 'VENDER' if x < -0.02 else 'MANTER'
    )
    
    st.dataframe(
        rebal_df.style.format({
            'Peso Atual': '{:.2%}',
            'Peso Alvo': '{:.2%}',
            'Diferen√ßa': '{:.2%}'
        }),
        width='stretch'
    )

    # ===== MANUAL DA P√ÅGINA =====
    st.markdown("---")
    with st.expander("üìñ Manual - Otimiza√ß√£o de Portf√≥lio", expanded=False):
        st.markdown('''
        ### üéØ Objetivo desta aba:
        Encontrar a aloca√ß√£o √≥tima de ativos baseada em diferentes estrat√©gias de otimiza√ß√£o.

        ### üìä Como interpretar as m√©tricas:
        - **Retorno Esperado**: Proje√ß√£o de retorno baseada em dados hist√≥ricos
        - **Volatilidade**: Risco medido pela variabilidade dos retornos
        - **Sharpe Ratio**: Retorno por unidade de risco (valores maiores = melhor)
        - **Fronteira Eficiente**: Curva de melhores combina√ß√µes risco-retorno

        ### üîß Como usar as ferramentas:
        1. Configure o per√≠odo de an√°lise e taxa livre de risco
        2. Analise a fronteira eficiente (curva azul)
        3. Compare estrat√©gias: Atual, M√°ximo Sharpe e Risk Parity
        4. Veja composi√ß√µes sugeridas para cada estrat√©gia
        5. Use sugest√µes de rebalanceamento para ajustar o portf√≥lio

        ### üí° Dicas importantes:
        - **M√°ximo Sharpe**: Melhor rela√ß√£o risco-retorno te√≥rica
        - **Risk Parity**: Distribui risco igualmente entre ativos
        - **Fronteira Eficiente**: Pontos √† esquerda s√£o ineficientes
        - **Rebalanceamento**: Considere custos de transa√ß√£o

        ### ‚ö†Ô∏è Considera√ß√µes importantes:
        - Otimiza√ß√µes baseadas em dados passados n√£o garantem futuro
        - Considere restri√ß√µes pessoais (liquidez, convic√ß√µes)
        - Monitore e rebalanceie periodicamente o portf√≥lio
        - Diversifique al√©m de criptoativos para reduzir risco total

        *√öltima atualiza√ß√£o: v2.0*
        ''')
